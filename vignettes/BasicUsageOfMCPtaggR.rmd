---
title: "Basic usage of MCPtaggR"
author: 
  -name: "Tomoyuki Furuta"
  affiliation: Institute of Plant Science and Resources, Okayama University, Okayama, Japan
  email: f.tomoyuki@okayama-u.ac.jp
date: "August 9, 2023"
package: MCPtaggR
output: 
  BiocStyle::html_document:
    toc: true
    toc_float: true
  BiocStyle::pdf_document: 
vignette: >
  %\VignetteIndexEntry{Basic usage of MCPtaggR}
  %\VignetteEncoding{UTF-8}
  %\VignetteEngine{knitr::rmarkdown}
---
```{r global_options, include=FALSE}
knitr::opts_chunk$set(fig.pos = 'H', fig.align = "center", warning = FALSE, message = FALSE)
```

# Introduction
MCPtaggR provides the functions to conduct mappable-collinear-polymorphic 
tag genotyping (MCPtagg). MCPtagg is a pipeline for 
next generation sequencing (NGS)-based genotyping technique to precisely 
detect SNPs and count reads on validated tags (short genome segments or 
regions) based on genome comparison information. Short NGS reads can not 
always be mapped to the proper positions on the reference genome if the reads 
were originally derived from a genome that have plenty polymorphisms and 
structural variations against the reference genome, e.g. mapping reads of a 
hybrid population that were derived from a cross between distant relatives. 
Polymorphic reads that were derived from a non-reference genome could result 
in mismapping and mapping bias. The mismapping and mappability bias
lead biased observation of mapped reads on SNP markers where 
reads of either allele are preferentially mapped. To eliminate unexpected 
detection of such error-prone markers, MCPtagg count reads only mapped on 
MCP tags that are the genomic sequences/regions on which NGS reads obtained by
RRS can be mapped uniquely and properly to call genotypes at SNPs. The list of 
MCP tags is obtained by whole genome sequence comparison between the genome 
sequences of the prarents of a given mapping/breeding population followed by 
sequencing read mappability assessment using simulated reads. 
The MCPtagg pipeline efficiently eliminates error-prone markers from your 
resultant genotype data obtained via a NGS-based genotyping technique, compared 
to the result produced by the conventional pipeline that maps reads on one
reference genome.
MCPtaggR currently supports NGS reads generated by reduced-representation 
sequence, e.g. genotyping-by-sequencing (GBS) and Restriction site associated 
DNA markers sequencing (RAD-seq), for a biparental population derived from
a cross between inbred parents. 

# Prerequisites
`MCPtaggR` requires external tools: MUMmer and Subreads. Please install these 
two tools on your system and make sure their executable files can be executed 
from your R environment. 
For installation of MUMmer, please visit [MUMmer's web site](https://mummer4.github.io/install/install.html).
For installation of Subread, please see [the vignette of Rsubread](https://bioconductor.org/packages/release/bioc/vignettes/Rsubread/inst/doc/SubreadUsersGuide.pdf).

# Installation
You can install `MCPtaggR` from the GitHub repository.
```
if (!requireNamespace("devtools", quietly = TRUE))
    install.packages("devtools")
    
devtools::install_github("tomoyukif/MCPtaggR", build_vignettes = FALSE)
```

# The basic pipeline
Load the package.
```{r warning=FALSE, message=FALSE}
library("MCPtaggR")
```
<br>
<br>

Set paths to input files.
```{r}
# Path to a directory containing FASTQ files
fq_dir <- system.file("extdata/fastq", package = "MCPtaggR")

# Path to a reference genome FASTA file
ref_fn <- system.file("extdata/ref/IRGSP-1.0_genome.masked.fa.gz", 
                      package = "MCPtaggR")

# Path to a alternative genome FASTA file
alt_fn <- system.file("extdata/ref/ol_genome_chr.masked.fa.gz", 
                      package = "MCPtaggR")

# Path to a directory containing MUMmer executable files
mummer_dir <- system.file("extdata/MUMmer3.23", package = "MCPtaggR")
out_dir <- tempdir()
```
<br>
<br>

Run MUMmer.
```{r eval=FALSE}
out_fn <- "mummer_out"
R.utils::gunzip(ref_fn, overwrite = TRUE, remove = FALSE)
R.utils::gunzip(alt_fn, overwrite = TRUE, remove = FALSE)
ref_fn <- sub("\\.gz", "", ref_fn)
alt_fn <- sub("\\.gz", "", alt_fn)
mummer_fn <- run_mummer(ref_fn = ref_fn, alt_fn = alt_fn,
                        mummer_dir = mummer_dir, 
                        out_dir = out_dir, out_fn = out_fn)
```
<br>
<br>

You can use pre-calculated mummer outputs from installation directory of MCPtaggR.
```{r}
mummer_fn <- c(system.file("extdata/mummer/ol2nb_mcptagg.snps.gz", 
                           package = "MCPtaggR"),
               system.file("extdata/mummer/ol2nb_mcptagg.coord.gz", 
                           package = "MCPtaggR"))
```
<br>
<br>

Import and organize information of SNPs in collinear blocks.
```{r eval=FALSE}
snps <- mummer2SNPs(mummer_fn = mummer_fn)
```
<br>
<br>
Execute in-silico digestion of the given genomes.
```{r eval=FALSE}
read_len <- 150
re_names <- c("PstI", "MspI")
re <- makeRE(re_names)
fragment_len = c(0, 1000)
out_fn <- "dgout"
dg <- digestGenome(snps = snps, ref_fn = ref_fn, alt_fn = alt_fn, 
                   out_dir = out_dir, read_len = read_len, 
                   re = re, fragment_len = fragment_len)
```
<br>
The function `makeRE()` outputs a data.frame that specify how restriction 
enzymes cut DNA sequences as shown below. 
```{r}
makeRE("KpnI")
```
The `site` column indicates the restriction pattern. In the case of KpnI, it 
recognizes GGTACC and cut the sequence between the 5th nucleotide and 
the 6th nucleotide. The `f` and `r` columns indicate how many bases away the 
remnant sequences start from in forward and reverse strands, respectively. 
For example, in the forward strand, the remnant sequence is GGTAC. Counting 
from the 1st nucleotide of the recognition sequence, the last nucleotide in the
remnant sequence locates at 4-bp downstream. On the other hand, the remnant 
sequence in the reverse strand is GTACC. Counting from the 1st nucleotide of the 
recognition sequence, the last nucleotide in the remnant sequence locates at 
1-bp upstream when you count nucleotides in the 5' to 3' direction in the 
reverse strand. Therefore, the data.frame generated by `makeRE()` represents the 
patterns of restriction remnant sequences. \  
Currently, `makeRE()` only supports KpnI, PstI, MspI and ApeKI for the `re_names`
argument. For other restriction enzymes, please specify recognition sequences to 
the `re_sites` argument, e.g. `re_sites = c("G/AATTC", "A/AGCTT")` for 
EcoRI and HindIII.
<br>
<br>

Align the simulated digested fragments to the given genomes.
```{r eval=FALSE}
ar <- alignTAG(dg = dg, out_dir = out_dir, 
               n_threads = 5, indexing = TRUE, reuse = TRUE)
```
<br>
<br>

Evaluate mappability of tags.
```{r eval=FALSE}
mcptag <- findMCPtag(ar = ar, dg = dg)
```
<br>
<br>

Count reads on the MCPtags.
```{r eval=FALSE}
fq_list <- findFASTQ(in_dir = fq_dir)
mcptagg <- mcptagg(mcptag = mcptag, fq_list = fq_list, out_dir = out_dir, 
                   n_threads = 5, n_parallel = 3)
```

# Post genotype calling workflow

The output GDS file can be manipulated using the 
[GBScleanR](https://doi.org/10.18129/B9.bioc.GBScleanR) package that provides
functions for data visualization, filtering, genotyping error correction, and 
allele dosage estimation.
```{r}
library(GBScleanR)
```
<br>
<br>

Open the connection to the GDS file.
```{r}
mcptagg <- system.file("extdata/genotype.gds", package = "MCPtaggR")
gds <- loadGDS(mcptagg)
```
<br>
<br>

Calculate and visualize summary statistics.
```{r}
gds <- countGenotype(gds)
gds <- countRead(gds)
histGBSR(x = gds, stats = "missing")
histGBSR(x = gds, stats = "het")
histGBSR(x = gds, stats = "raf")
histGBSR(x = gds, stats = "dp")
```
<br>
<br>

Apply filtering on SNPs.
```{r}
# Retain only one SNP if multiple SNPs in a 150 bp stretch.
gds <- thinMarker(object = gds, range = 150)
# Filter out SNPs at which all samples shows missing.
gds <- setMarFilter(object = gds, missing = 0.9999)
nmar(gds)
```
<br>
<br>

Re-calculate and visualize summary statistics for the filtered data.
```{r}
gds <- countGenotype(gds)
gds <- countRead(gds)
histGBSR(x = gds, stats = "missing")
histGBSR(x = gds, stats = "het")
histGBSR(x = gds, stats = "raf")
histGBSR(x = gds, stats = "dp")
```
<br>
<br>

Genotyping error correction and dosage estimation.
```{r eval = FALSE}
gds <- initScheme(object = gds, mating = cbind(c(1, 2)))
gds <- addScheme(object = gds, crosstype = "selfing")
gds <- estGeno(gds, het_parent = FALSE, iter = 4, n_threads = 10)
```
<br>
<br>

Visualize read ratio and estimated dosage 
```{r}
plotReadRatio(x = gds, ind = 1, alpha = 0.8)
```
<br>
Due to the dosage estimation conducted on the data with too few reads and few 
samples, the estimated dosage is highly fluctuated and obviously contains error.
```{r}
plotDosage(x = gds, ind = 1, alpha = 0.8)
```
<br>

The follwing plot shows the estimated dosage that generated by running estGen()
on 813 samples.
```{r echo = FALSE}
img <- png::readPNG(system.file("extdata/sample.png", package = "MCPtaggR"))
par(mar = c(0, 0, 0, 0))
plot(c(0, 100), c(0, 100), type = "n", xlab = "", ylab = "", 
     axes = FALSE, ann = FALSE)
rasterImage(img, xleft = 0, ybottom = 0, xright = 100, ytop = 100)
```

# Session info{-}
```{r}
sessionInfo()
```

