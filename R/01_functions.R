################################################################################
# Execute MUMmer
#' Execute MUMmer
#' 
#' A wrapper function to execute MUMmer from an R environment. This function 
#' requires the path of the MUMmer executable file on your system.
#' 
#' @param ref_fn A string to specify the path to the reference genome fasta. 
#' @param alt_fn A string to specify the path to the alternative genome fasta.
#' @param mummer_dir A string to specify the directory in which 
#' the MUMmer executable files including nucmer, delta_filter, show-snps, and 
#' show-coords exist.
#' @param out_dir A string to specify the output directory.
#' @param out_fn A string to specify the prefix of output files.
#'
#' @details MUMmer is a tool to compare a genome sequence against another
#' and detect identical genomic region between the given genomes. In addition, 
#' the tool also detect polymorphisms and structural variations. Thus,
#' `run_mummer` requires a reference genome fasta and another to be specified as 
#' `ref_fn` and `alt_fn`. The alleles found in the reference genome would be listed as
#' reference alleles in the output vcf file of `mcptagg()`, whereas the alleles 
#' found in another specified as `alt_fn` would be alternative alleles. Running 
#' MUMmer on repetitive sequences will take longer execution time.
#' Masking repetitive sequences is highly recommended before running MUMmer.
#' Please run RepeatMasker or a similar tool on your genomes first, and then
#' use the masked genome sequences as input to `run_mummer()`.
#' 
#' @return a vector of strings indicating the paths to the output files.
#' 
#' @examples 
#' \dontrun{
#' mummer_out <- run_mummer(ref_fn = "reference_genome.fa",
#'                          alt_fn = "alternative_genome.fa",
#'                          mummer_dir = "path/to/mummer",
#'                          out_dir = "mummer_out",
#'                          out_fn = "mummer_result")
#' }
#' 
#' @export
#' 
run_mummer <- function(ref_fn,
                       alt_fn, 
                       mummer_dir,
                       out_dir = "", 
                       out_fn = "mummer_out"){
    dir.create(out_dir, showWarnings = FALSE)
    
    # Run nucmer
    command <- paste(mummer_dir, "nucmer", sep = "/")
    out_p <- paste(out_dir, out_fn, sep = "/")
    args <- paste("--maxmatch", "-g 1000", "-p", out_p , ref_fn, alt_fn)
    system2(command, args)
    
    # Run delta-filter
    command <- paste(mummer_dir, "delta-filter", sep = "/")
    delta_fn <- paste0(out_dir, "/", out_fn, ".delta")
    args <- paste("-1g", delta_fn, ">", paste0(out_p, ".filt"))
    system2(command, args)
    
    # Run show-snps
    command <- paste(mummer_dir, "show-snps", sep = "/")
    filt_fn <- paste0(out_dir, "/", out_fn, ".filt")
    snps_fn <- paste0(out_p, ".snps")
    args <- paste("-CTlr", filt_fn, ">", snps_fn)
    system2(command, args)
    
    # Run show-snps
    command <- paste(mummer_dir, "show-coords", sep = "/")
    coord_fn <- paste0(out_p, ".coord")
    args <- paste("-Tlr", filt_fn, ">", coord_fn)
    system2(command, args)
    
    return(c(snps_fn = snps_fn, coord_fn = coord_fn))
}


################################################################################
# Make SNP list from mummer results
#' Import the MUMmer output files
#' 
#' Import .snps and .coord files generated by MUMmer and then apply a filtering 
#' to only retain SNPs in collinear blocks detected between the reference and
#' the alternative genomes given to MUMmer.
#' 
#' @param mummer_fn A vector of two strings indicating a path to.snps file and 
#' a path to .coord file generated by MUMmer.
#'
#' @importFrom data.table fread
#' @importClassesFrom IRanges IRanges
#' @importClassesFrom GenomicRanges GRanges
#' @importFrom GenomicRanges GRanges findOverlaps
#' @importFrom IRanges IRanges
#' @importFrom S4Vectors queryHits
#'
#' @return A SNPs class object storing available single nucleotide polymorphisms
#' (SNPs) information.
#' 
#' @examples 
#' \dontrun{
#' snps <- mummer2SNPs(mummer_fn = c("path/to/mummer.snps",
#'                                   "path/to/mummer.coord"))
#' }
#' 
#' @export
#'
mummer2SNPs <- function(mummer_fn){
    snps <- fread(file = mummer_fn[1],
                  header = FALSE,
                  skip = 4,
                  sep = "\t",
                  colClasses = c("integer", "factor", "factor",
                                 "integer", "integer", "integer",
                                 "integer", "integer", "integer", "integer",
                                 "factor", "factor"))
    message("Number of SNPs: ", nrow(snps))
    ref_chr <- levels(snps$V11)
    ref_chr <- gsub("[^0-9]", "", ref_chr)
    ref_chr <- as.numeric(ref_chr)
    ref_chr <- ref_chr[as.numeric(snps$V11)]
    alt_chr <- levels(snps$V12)
    alt_chr <- gsub("[^0-9]", "", alt_chr)
    alt_chr <- as.numeric(alt_chr)
    alt_chr <- alt_chr[as.numeric(snps$V12)]
    trans_chr <- which(ref_chr != alt_chr)
    snps <- snps[-trans_chr, ]
    message("Number of SNPs after filtering out",
            " inter-chromosomally translocated SNPs: ",
            nrow(snps))
    unknown <- which(snps$V2 %in% c("N", ".") | snps$V3 %in% c("N", "."))
    snps <- snps[-unknown, ]
    message("Number of SNPs after filtering out SNPs at N: ",
            nrow(snps))
    ref_snps <- GRanges(snps$V11, IRanges(snps$V1, width = 1))
    ref_snps$allele <- snps$V2
    ref_snps$buff <- snps$V5
    ref_snps$dist <- snps$V6
    alt_snps <- GRanges(snps$V12, IRanges(snps$V4, width = 1))
    alt_snps$allele <- snps$V3
    
    coord <- fread(file = mummer_fn[2],
                   header = FALSE,
                   skip = 4,
                   sep = "\t",
                   colClasses = c("integer", "integer", "integer", "integer",
                                  "integer", "integer", "numeric", "integer",
                                  "integer", "factor", "factor"))
    ref_chr <- as.numeric(gsub("[^0-9]", "", levels(coord$V10)))
    ref_chr <- ref_chr[as.numeric(coord$V10)]
    alt_chr <- as.numeric(gsub("[^0-9]", "", levels(coord$V11)))
    alt_chr <- alt_chr[as.numeric(coord$V11)]
    trans_chr <- which(ref_chr != alt_chr)
    coord <- coord[-trans_chr, ]
    
    ref_coord <- GRanges(coord$V10, IRanges(coord$V1, coord$V2))
    
    hits <- unique(queryHits(findOverlaps(ref_snps, ref_coord)))
    ref_snps <- ref_snps[hits]
    alt_snps <- alt_snps[hits]
    ref_snps$id <- seq_along(ref_snps)
    alt_snps$id <- seq_along(alt_snps)
    
    snps <- list(ref = ref_snps, alt = alt_snps)
    class(snps) <- c(class(snps), "SNPs")
    return(snps)
}

#' Build a RE object
#' 
#' A RE object stores the information of recognition sequences of restriction 
#' enzymes (REs) and also the remnant sequences after the cut by the REs. 
#' 
#' @param re_names A character vector to indicate the names of REs. 
#' @param re_sites A character vector to indicate the RE recognition sites.
#' 
#' @return A RE object.
#' 
#' @details The RE object produced via this function is required to run 
#' `digestGenome()`. The order of strings specified to `re_names` and `re_sites`
#' are important so that the first one indicates the cut site found in the 
#' forward reads (Read 1 of the NGS output) while the second one indicates the 
#' cut site found in the reverse reads (Read 2 of the NGS output).
#' If not `re_sites = NULL`, `re_names` will be ignored and 
#' make a RE object using specified `re_sites` information. `re_sites` requires 
#' a vector of strings in which each string represent the recognition sequence 
#' and the cut position on the top strand. For example, the site of PstI should 
#' be specified as `re_sites = "CTGCA/G"` in which the recognition sequence is 
#' "CTGCAG" and the cut site is the position between the 5th A and the 6th G.
#' The currently supported REs that can be specified to `re_names` are listed 
#' below.
#' * KpnI
#' * PstI
#' * MspI
#' * ApeKI
#' @md
#' 
#' @examples 
#' \dontrun{
#' re_names <- c("KpnI", "MspI")
#' re <- makeRE(re_names)
#' }
#' 
#' @export
#' 
makeRE <- function(re_names = NULL, re_sites = NULL){
    if(is.null(re_sites) & !is.null(re_names)){
        stopifnot(length(re_names) %in% c(1, 2))
        if("PstI" %in% re_names){
            re_sites <- c(re_sites, "CTGCA/G")
        }
        if("KpnI" %in% re_names){
            re_sites <- c(re_sites, "GGTAC/C")
        }
        if("MspI" %in% re_names){
            re_sites <- c(re_sites, "C/CGG")
        }
        if("ApeKI" %in% re_names){
            re_sites <- c(re_sites, "G/CWGC")
        }
    }
    
    out <- NULL
    for(i_site in re_sites){
        len <- nchar(i_site)
        cut_pos <- unlist(gregexec("/", i_site))
        top2 <- len - cut_pos
        top1 <- cut_pos - top2
        if(top1 < top2){
            if(is.null(out)){
                f <- 0
                r <- top2 - cut_pos
            } else {
                f <- top2 - cut_pos
                r <- 0
            }
        } else {
            if(is.null(out)){
                f <- top1 - top2
                r <- -1
            } else {
                f <- -1
                r <- top1 - top2
            }
        }
        out <- rbind(out, data.frame(site = i_site, f = f, r = r))
    }
    return(out)
}

################################################################################
### Make RE site lists, detectable SNP list, and digested genome fragments
#' In silico digestion of the input genomes
#' 
#' Search recognition sites of the specified restriction enzymes in the given 
#' genome sequences and generate FASTA files of the simulated digested fragments.
#' 
#' @param snps A SNPs object.
#' @param ref_fn A string to specify the path to the reference genome FASTA. 
#' @param alt_fn A string to specify the path to the alternative genome FASTA.
#' @param out_dir A string to specify the output directory.
#' @param read_len The maximum length of reads in FASTQ to be mapped on the 
#' genomes in the read mapping step.
#' @param re The recognition sequences of restriction enzymes used in your 
#' reduced representation sequencing. 
#' @param fragment_len A vector of two integers indicating the range of 
#' acceptable fragment lengths. 
#' @param reuse If TRUE, this function do not generate output files but reuse
#' the files created by `digestGenome()` in the out_dir directory in the 
#' previous execution of `digestGenome()`.
#' 
#' @details The `re`, `read_len`, and `fragment_len` arguments should match with the 
#' restriction enzymes, read length, and fragment lengths that were used and 
#' sequenced in your NGS run. If you applied size selection on your sequencing 
#' library during library preparation, `fragment_len` should match with the 
#' range of the size selection you did.
#' 
#' @return A DG object that is required to run `alignTAG()`
#' 
#' @examples 
#' \dontrun{
#' dg <- digestGenome(snps = snps, 
#'                    ref_fn = "path/to/ref.fa",
#'                    alt_fn = "path/to/alt.fa",
#'                    out_dir = "outdir", 
#'                    read_len = 150,
#'                    re = re,
#'                    fragment_len = c(100, 600), 
#'                    reuse = FALSE)
#' }
#' 
#' @importFrom Biostrings readDNAStringSet writeXStringSet
#' @importFrom GenomeInfoDb seqlevels seqlevels<- seqnames
#' @importFrom BiocGenerics start
#' @import BSgenome
#'
#' @export
digestGenome <- function(snps,
                         ref_fn,
                         alt_fn, 
                         out_dir = "", 
                         read_len = 150, 
                         re,
                         fragment_len = c(0, 1000),
                         reuse = FALSE){
    stopifnot(inherits(snps, "SNPs"))
    dir.create(out_dir, showWarnings = FALSE)
    
    ref_genome <- readDNAStringSet(ref_fn)
    ref_seg <- .insilicoRE(ref_genome, re)
    ref_seg <- .checkWidth(ref_seg, fragment_len)
    ref_snps <- .validSnps(ref_seg, snps$ref, read_len)
    alt_genome <- readDNAStringSet(alt_fn)
    alt_seg <- .insilicoRE(alt_genome, re)
    alt_seg <- .checkWidth(alt_seg, fragment_len)
    alt_snps <- .validSnps(alt_seg, snps$alt, read_len)
    
    fastq_fn <- c(paste0(out_dir, "/ref_R1.fq.gz"),
                  paste0(out_dir, "/ref_R2.fq.gz"),
                  paste0(out_dir, "/alt_R1.fq.gz"),
                  paste0(out_dir, "/alt_R2.fq.gz"))
    names(fastq_fn) <- c("ref_r1", "ref_r2", "alt_r1", "alt_r2")
    genome_fn <- paste0(out_dir, "/merge.fa.gz")
    check <- TRUE
    if(reuse){
        if(all(file.exists(fastq_fn)) & file.exists(genome_fn)){
            check <- FALSE
        }
    }
    
    rgn <- names(ref_genome)
    agn <- names(alt_genome)
    rsn <- seqlevels(ref_snps)
    asn <- seqlevels(alt_snps)
    rsg <- seqlevels(ref_seg)
    asg <- seqlevels(alt_seg)
    rsn_i <- as.numeric(gsub("[^0-9]", "", rsn))
    rsn <- paste0("chr", sprintf("%02d", rsn_i))
    rgn_i <- as.numeric(gsub("[^0-9]", "", rgn))
    rgn <- paste0("chr", sprintf("%02d", rgn_i))
    rsg_i <- as.numeric(gsub("[^0-9]", "", rsg))
    rsg <- paste0("chr", sprintf("%02d", rsg_i))
    asn_i <- as.numeric(gsub("[^0-9]", "", asn))
    asn <- paste0("chr", sprintf("%02d", asn_i))
    agn_i <- as.numeric(gsub("[^0-9]", "", agn))
    agn <- paste0("chr", sprintf("%02d", agn_i))
    asg_i <- as.numeric(gsub("[^0-9]", "", asg))
    asg <- paste0("chr", sprintf("%02d", asg_i))
    names(ref_genome) <- paste0("ref_", rgn)
    names(alt_genome) <- paste0("alt_", agn)
    seqlevels(ref_snps) <- paste0("ref_", rsn)
    seqlevels(alt_snps) <- paste0("alt_", asn)
    seqlevels(ref_seg) <- paste0("ref_", rsg)
    seqlevels(alt_seg) <- paste0("alt_", asg)
    ref_genome <- ref_genome[order(as.numeric(gsub("[^0-9]", "", names(ref_genome))))]
    alt_genome <- alt_genome[order(as.numeric(gsub("[^0-9]", "", names(alt_genome))))]
    ref_snps <- ref_snps[order(as.numeric(gsub("[^0-9]", "", seqnames(ref_snps))), start(ref_snps))]
    alt_snps <- alt_snps[order(as.numeric(gsub("[^0-9]", "", seqnames(alt_snps))), start(alt_snps))]
    ref_seg <- ref_seg[order(as.numeric(gsub("[^0-9]", "", seqnames(ref_seg))), start(ref_seg))]
    alt_seg <- alt_seg[order(as.numeric(gsub("[^0-9]", "", seqnames(alt_seg))), start(alt_seg))]
    
    dg <- list(seg = list(ref = ref_seg, alt = alt_seg),
               snps = list(ref = ref_snps, alt = alt_snps),
               fq = fastq_fn, genome = genome_fn)
    class(dg) <- c(class(dg), "DG")
    
    if(check){
        ref_reads <- .getReads(ref_genome, ref_seg, read_len)
        writeXStringSet(ref_reads$read1, fastq_fn[1],
                        compress = TRUE, format = "fastq")
        writeXStringSet(ref_reads$read2, fastq_fn[2],
                        compress = TRUE, format = "fastq")
        
        alt_reads <- .getReads(alt_genome, alt_seg, read_len)
        writeXStringSet(alt_reads$read1, fastq_fn[3],
                        compress = TRUE, format = "fastq")
        writeXStringSet(alt_reads$read2, fastq_fn[4],
                        compress = TRUE, format = "fastq")
        
        genome <- c(ref_genome, alt_genome)
        writeXStringSet(genome, genome_fn,
                        compress = TRUE, format = "fasta")
    }
    
    return(dg)
}

.checkWidth <- function(seg, fragment_len){
    seg_w <- width(seg)
    valid <- seg_w >= fragment_len[1] & seg_w <= fragment_len[2]
    return(seg[valid])
}

#' @importFrom XVector subseq
#' @importFrom Biostrings reverseComplement
.getReads <- function(genome, seg, read_len){
    reads <- genome[seg]
    long_reads <- width(reads) > read_len
    read1 <- reads
    read1[long_reads] <- subseq(read1[long_reads],
                                start = 1, width = read_len)
    names(read1) <- paste(seqnames(seg), start(seg), end(seg), "R1", sep = "_")
    read2 <- reverseComplement(reads)
    read2[long_reads] <- subseq(read2[long_reads],
                                start = 1, width = read_len)
    names(read2) <- paste(seqnames(seg), start(seg), end(seg), "R2", sep = "_")
    return(list(read1 = read1, read2 = read2))
}

#' @importFrom GenomicRanges resize findOverlaps width
#' @importFrom S4Vectors queryHits
.validSnps <- function(seg, snps, read_len){
    seg_w <- width(seg)
    long_seg <- seg_w > read_len * 2
    short_seg <- seg[!long_seg]
    long_seg1 <- resize(seg[long_seg], width = 150)
    long_seg2 <- resize(seg[long_seg], width = 150, "end")
    ol <- findOverlaps(snps, c(short_seg, long_seg1, long_seg2))
    return(snps[unique(queryHits(ol))])
}

#' @importFrom DECIPHER DigestDNA
#' @importFrom GenomicRanges GRanges
#' @importFrom IRanges IRanges
#' @importFrom BiocGenerics start<- end<-
.insilicoRE <- function(genome, re){
    if(nrow(re) == 1){
        re_sites <- DigestDNA(re$site[1], genome, "position", "top")
        re_sites <- unlist(re_sites)
        re_sites <- data.frame(chr = sub("\\..*", "", names(re_sites)),
                               pos = unlist(re_sites))
        re_sites <- re_sites[order(re_sites$chr, re_sites$pos), ]
        valid <- rep(TRUE, nrow(re_sites) - 1)
        valid_seg <- cbind(re_sites[c(valid, FALSE), ],
                           re_sites[c(FALSE, valid), ])
        valid_seg <- valid_seg[valid_seg[, 1] == valid_seg[, 3], ]
        valid_seg$strand <- "+"
        valid_seg <- GRanges(valid_seg[, 1],
                             IRanges(valid_seg[, 2], valid_seg[, 4]),
                             valid_seg$strand)
        st <- as.character(strand(valid_seg))
        start(valid_seg[st == "+"]) <- start(valid_seg[st == "+"]) - re$f[1]
        end(valid_seg[st == "+"]) <- end(valid_seg[st == "+"]) + re$r[1]
        
    } else if (nrow(re) == 2){
        re1 <- DigestDNA(re$site[1], genome, "position", "top")
        re1 <- unlist(re1)
        re1 <- data.frame(chr = sub("\\..*", "", names(re1)),
                          pos = unlist(re1),
                          re = "re1")
        re2 <- DigestDNA(re$site[2], genome, "position", "top")
        re2 <- unlist(re2)
        re2 <- data.frame(chr = sub("\\..*", "", names(re2)),
                          pos = unlist(re2),
                          re = "re2")
        re_sites <- rbind(re1, re2)
        re_sites <- re_sites[order(re_sites$chr, re_sites$pos), ]
        valid <- re_sites$re[1:(nrow(re_sites) - 1)] != re_sites$re[2:nrow(re_sites)]
        valid_seg <- cbind(re_sites[c(valid, FALSE), ], re_sites[c(FALSE, valid), ])
        valid_seg <- valid_seg[valid_seg[, 1] == valid_seg[, 4], ]
        valid_seg$strand <- "+"
        valid_seg$strand[valid_seg[, 3] == "re2"] <- "-"
        valid_seg <- GRanges(valid_seg[, 1],
                             IRanges(valid_seg[, 2], valid_seg[, 5]),
                             valid_seg$strand)
        st <- as.character(strand(valid_seg))
        start(valid_seg[st == "+"]) <- start(valid_seg[st == "+"]) - re$f[1]
        end(valid_seg[st == "+"]) <- end(valid_seg[st == "+"]) + re$f[2]
        start(valid_seg[st == "-"]) <- start(valid_seg[st == "-"]) - re$r[2]
        end(valid_seg[st == "-"]) <- end(valid_seg[st == "-"]) + re$r[1]
    }
    return(valid_seg)
}

################################################################################
# Align reads obtained from the digested genome
#' 
#' Align simulated digested fragments.
#' 
#' @param dg A DG object. 
#' @param out_dir A string to specify the output directory.
#' @param n_threads A integer to specify the number of threads to run the read
#' alignment.
#' @param indexing A logical value to indicate whether you need to build index 
#' files of the merged genome the generated via `digestGenome()`.
#' @param reuse If TRUE, this function do not generate output files but reuse
#' the files specified as out_fn in the out_dir directory.
#' 
#' @return A AR class object used in `mcptagg()`.
#' 
#' @details An input DG class object has a string indicating the path to 
#' the merged genome that was generated via `digestGenome()` and contains genome
#' sequences of both genomes specified as `ref_fn` and `alt_fn` to run
#' `digestGenome()`. The merged genome has to be indexed for read alignment. If 
#' you run `alignTAG()` on the merged genome first time, `indexing = TRUE` 
#' should always be specified. `reuse = TRUE` can omit the indexinig step if you 
#' already have the index files for the merged genome that is pointed by the GD
#' class object.
#' 
#' @examples 
#' \dontrun{
#' ar <- alignTAG(dg = dg, 
#'                n_threads = 10, 
#'                indexing = TRUE,
#'                out_dir = "outdir",
#'                out_fn = "out",
#'                reuse = FALSE)
#' }
#' 
#' @importFrom Rsubread buildindex align
#' @importFrom Rsamtools sortBam
#' @export
alignTAG <- function(dg,
                     out_dir = "",
                     n_threads = 1,
                     indexing = TRUE,
                     reuse = FALSE){
    stopifnot(inherits(dg, "DG"))
    dir.create(out_dir, showWarnings = FALSE)
    index_fn <- paste0(out_dir, "/merge")
    bam_fn <- paste(out_dir, 
                    c("merge_ref.bam", "merge_alt.bam"),
                    sep = "/")
    
    if(!reuse | !all(file.exists(bam_fn))){
        if(indexing){
            buildindex(index_fn, dg$genome)
        }
        
        ref_aln <- align(index_fn, dg$fq["ref_r1"], dg$fq["ref_r2"],
                         type = "dna", output_file = bam_fn[1],
                         nthreads = n_threads, maxMismatches = 0, unique = TRUE,
                         indels = 0)
        alt_aln <- align(index_fn, dg$fq["alt_r1"], dg$fq["alt_r2"],
                         type = "dna", output_file = bam_fn[2],
                         nthreads = n_threads, maxMismatches = 0, unique = TRUE,
                         indels = 0)
        for(i in seq_along(bam_fn)){
            sortBam(bam_fn[i], sub("\\.bam", "", bam_fn[i]), byQname=TRUE)
        }
    } else {
        ref_aln <- alt_aln <- NA
    }
    
    ar <- list(aln_stats = cbind(ref_aln, alt_aln),
               bam_fn = bam_fn, index_fn = index_fn)
    class(ar) <- c(class(ar), "AR")
    return(ar)
}


################################################################################
#'
#' Find mappable-collinear-polymorphic tags
#' 
#' Find mappable-collinear-polymorphic tags (MCPtags) based on the information 
#' given by the AR and GD class object
#' 
#' @param ar An AR class object produced by `alignTAG()`.
#' @param dg A DG class object produced by `digestGenome()`.
#' 
#' @return A MCPtag classs object.
#' 
#' @details Based on the alignment results of simulated digested genome, 
#' this function list up mappable-collibear-polymorphic tags that are validated 
#' to be used for genotyping a given population derived from a cross between 
#' founders having the reference genome and the alternative genome that were 
#' specified as `ref_fn` and `alt_fn` in `run_mummer()`, `digestGenome()`, and 
#' `alignTAG()`.
#'
#' @importFrom Rsamtools scanBam
#' @importFrom GenomicRanges findOverlaps
#' @importFrom S4Vectors subjectHits
#' @importFrom dplyr intersect
#' 
#' @examples 
#' \dontrun{
#' mcptag <- findMCPtag(ar = ar, dg = dg)
#' }
#' 
#' @export
#' 
findMCPtag <- function(ar, dg){
    stopifnot(inherits(ar, "AR"))
    stopifnot(inherits(dg, "DG"))
    dg <- .getPairedTag(dg)
    bam1 <- scanBam(ar$bam_fn[1])[[1]]
    seg_ref <- .pickValidTag(bam1, dg$seg$ref)
    
    bam2 <- scanBam(ar$bam_fn[2])[[1]]
    seg_alt <- .pickValidTag(bam = bam2, seg = dg$seg$alt)
    
    ref_ol <- findOverlaps(seg_ref, dg$snps$ref)
    alt_ol <- findOverlaps(seg_alt, dg$snps$alt)
    valid_snps <- intersect(subjectHits(ref_ol), subjectHits(alt_ol))
    out <- list(ref = dg$snps$ref[valid_snps], alt = dg$snps$alt[valid_snps])
    out$index_fn <- ar$index_fn
    class(out) <- c(class(out), "MCPtag")
    return(out)
}

.getPairedTag <- function(dg){
    valid <- (dg$snps$ref$id %in% dg$snps$alt$id)
    valid_id <- dg$snps$ref$id[valid]
    dg$snps$ref <- dg$snps$ref[dg$snps$ref$id %in% valid_id]
    dg$snps$alt <- dg$snps$alt[dg$snps$alt$id %in% valid_id]
    valid_ref_seg <- findOverlaps(dg$seg$ref, dg$snps$ref)
    dg$seg$ref$valid <- FALSE
    dg$seg$ref$valid[unique(queryHits(valid_ref_seg))] <- TRUE
    valid_alt_seg <- findOverlaps(dg$seg$alt, dg$snps$alt)
    dg$seg$alt$valid <- FALSE
    dg$seg$alt$valid[unique(queryHits(valid_alt_seg))] <- TRUE
    return(dg)
}

#' @importFrom GenomicRanges resize
#' @importFrom BiocGenerics width
.pickValidTag <- function(bam, seg){
    max_len <- max(bam$qwidth, na.rm = TRUE)
    long_seg <- width(seg) > max_len
    seg1 <- seg2 <- seg
    seg1[long_seg] <- resize(seg1[long_seg], max_len)
    seg2[long_seg] <- resize(seg2[long_seg], max_len, "end")
    seg <- c(seg1, seg2)
    seg[c(TRUE, FALSE)] <- seg1
    seg[c(FALSE, TRUE)] <- seg2
    
    valid <- grepl("^[0-9]*M$", bam$cigar)
    valid <- valid & bam$rname == as.character(seqnames(seg))
    valid <- valid & bam$pos == start(seg)
    seg$qname <- bam$qname
    seg$seq <- bam$seq
    seg$tag <- rep(seq_len(length(seg)/2), each = 2)
    seg <- seg[valid]
    return(seg)
}

################################################################################
#' Merge genome sequence data and build a MCPtag class object
#' 
#' This function provide a pipeline to skip the mappability validation conducted
#' via `digestGenome()`, `alignTAG()`, and `findMCPtag()`. 
#' 
#' @param snps A SNPs class object.
#' @param ref_fn A string to specify the path to the reference genome FASTA. 
#' @param alt_fn A string to specify the path to the alternative genome FASTA.
#' @param out_dir A string to specify the output directory.
#' @param out_fn A string to specify the prefix of output files.
#' @param indexing A logical value to indicate whether you need to build index 
#' files of the merged genome that would be generated by this function.
#' 
#' @return A MCPtag class object.
#' 
#' @details similar with `findMCPtag()`, `mergeGenome()` also returns a
#' `MCPtag` class object, However, `mergeGenome()` does not evaluate mappability
#' of collinear-polymorphic tags found by MUMmer, while you can skip a time 
#' consuming mappability validation step. To get the best result by MCPtagg, it 
#' is highly recommended to validate mappability.
#' 
#'
#' @importFrom Rsubread align buildindex
#' @importFrom Rsamtools scanBamFlag ScanBamParam scanBam
#' @importFrom BiocGenerics width
#' @importFrom GenomeInfoDb seqlevels seqlevels<-
#' 
#' @examples 
#' \dontrun{
#' mcptag <- mergeGenome(snps = snps,
#'                       ref_fn = "path/to/ref.fa",
#'                       alt_fn = "path/to/alt.fa",
#'                       out_dir = "",
#'                       out_fn = "merge_genome",
#'                       indexing = TRUE)
#' }
#' 
#' @export
#' 
mergeGenome <- function(snps,
                        ref_fn,
                        alt_fn, 
                        out_dir = "",
                        out_fn = "merged_genome",
                        indexing = TRUE){
    stopifnot(inherits(snps, "SNPs"))
    dir.create(out_dir, showWarnings = FALSE)
    ref_genome <- readDNAStringSet(ref_fn)
    alt_genome <- readDNAStringSet(alt_fn)
    rgn <- names(ref_genome)
    agn <- names(alt_genome)
    rsn <- seqlevels(snps$ref)
    asn <- seqlevels(snps$alt)
    rsn_i <- as.numeric(gsub("[^0-9]", "", rsn))
    rsn <- paste0("chr", sprintf("%02d", rsn_i))
    rgn_i <- as.numeric(gsub("[^0-9]", "", rgn))
    rgn <- paste0("chr", sprintf("%02d", rgn_i))
    asn_i <- as.numeric(gsub("[^0-9]", "", asn))
    asn <- paste0("chr", sprintf("%02d", asn_i))
    agn_i <- as.numeric(gsub("[^0-9]", "", agn))
    agn <- paste0("chr", sprintf("%02d", agn_i))
    
    names(ref_genome) <- paste0("ref_", rgn)
    names(alt_genome) <- paste0("alt_", agn)
    seqlevels(snps$ref) <- paste0("ref_", rsn)
    seqlevels(snps$alt) <- paste0("alt_", asn)
    genome <- c(ref_genome, alt_genome)
    genome_fn <- paste0(out_dir, "/", out_fn, ".fa.gz")
    writeXStringSet(genome, genome_fn,
                    compress = TRUE, format = "fasta")
    index_fn <- paste0(out_dir, "/", out_fn)
    if(indexing){
        buildindex(index_fn, genome_fn)
        
    } else {
        check <- file.exists(paste0(index_fn, ".files"))
        if(!check){
            warning(index_fn, " does not exist.\n Need inexing,")
        }
    }
    out <- list(ref = snps$ref, alt = snps$alt, index_fn = index_fn)
    class(out) <- c(class(out), "MCPtag")
    return(out)
}


#' List up FASTQ files to be processed
#' 
#' Find FASTQ files in the specified directory and make a list of FASTQ files.
#' 
#' @param in_dir A string to indicate the path to the directory storing FASTQ files.
#' @param pattern A string to specify the pattern that should be contained in 
#' the FASTQ file names to be returned.
#' @param ignore A string to specify the pattern that should not be contained in 
#' the FASTQ file names to be returned.
#' 
#' @return A data.frame indicating FASTQ files and sample IDs.
#' 
#' @details This function searches the files with the .fq or .fastq extension.
#' Compressed files with the .gz extension can also be detected.  Samples IDs 
#' are automatically obtained by removing characters after _ in the FASTQ file 
#' names. The strings specified to `pattern` and `ignore` will be used to 
#' specify the `pattern` argument in the `grep()` function. The FASTQ files 
#' listed by `findFASTQ()` should be a set of a single file for each sample, 
#' each file of which is of a single end FASTQ or merged pair end FASTQ files, 
#' or a set of a pair of files for each samples, each file of which is of a pair 
#' end FASTQ file.
#' 
#' @examples 
#' \dontrun{
#' in_dir <- "path/to/directory/containing/FASTQ_files"
#' pattern <- "pattern_in_filename_should_be_matched"
#' ignore <- "pattern_in_filename_should_not_be_matched"
#' fq_list <- findFASTQ(in_dir, pattern, ignore)
#' }
#' 
#' @export
findFASTQ <- function(in_dir, pattern = NULL, ignore = NULL, id = NULL){
    out <- list.files(in_dir, "\\.fq|\\.fastq", full.names = TRUE)
    if(!is.null(pattern)){
        out <- grep(pattern, out, value = TRUE)
    }
    if(!is.null(ignore)){
        out <- grep(ignore, out, value = TRUE, invert = TRUE)
    }
    out <- sort(out)
    if(!is.null(id)){
        ids <-  gsub("_.*", "", basename(out))
        ids <- sub(id, "", ids)
    } else {
        ids <-  gsub("_.*", "", basename(out))
    }
    dup <- duplicated(ids)
    n_dup <- sum(dup)
    if(n_dup == 0){
        message("FASTQ files are provided as a single file for each sample")
        out <- data.frame(fq_name = out, id = ids)
    } else if(n_dup == length(dup)/2){
        message("FASTQ files are provided as a pair of files for each sample")
        fq1 <- grep("1\\.", out, value = TRUE)
        fq2 <- grep("2\\.", out, value = TRUE)
        ids <- ids[dup]
        out <- data.frame(fq1 = fq1, fq2 = fq2, id = ids)
    } else {
        stop("Cannot identify the files are provided as a single file or ",
             "a pair of files for each sample.",
             "\nSome samples have two FASTQ files, while the othres have a ",
             "single FASTQ file.")
    }
    return(out)
}
################################################################################
# Count reads
#'　
#' Count reads on MCPtags
#' 
#' Align reads on the MCPtags and count the mapped reads.
#' 
#' @param mcptag A MCPtag class object.
#' @param fq_list A character matrix to indicate input FASTQ files. See details.
#' @param out_dir A string to specify the output directory.
#' @param n_threads A integer to specify the number of threads to run the read
#' alignment.
#' @param n_parallel A integer to specify the number of concurrent sessions to 
#' run read alignments.
#' @param vcf A logical value to indicate whether a VCF file should be created 
#' or not. If `FALSE`, create only a GDS file.
#' @param bam_list A character matrix to indicate BAM files that have already 
#' been created via read alignment.
#' 
#' @return A vector of string(s) indicating the path(s) of the output GDS file
#' and the output VCF file if `vcf = TRUE`.
#' 
#' @details Align reads by the `Rsubread::align()` on the MCPtags prepared by 
#' `findMCPtag()` or `mergeGenome()`. This function output bam files into 
#' `out_dir` and the result of SNP calling and read counts as a GDS file. A GDS
#' file is the file formatted in the Genomic Data Structure format. You can 
#' access a GDS file using the `gdsfmt` package. `SeqArray` and `SNPRelate` also
#' provide functions to manipulate a GDS file. `GBScleanR` enable you to 
#' estimate true genotypes, haplotypes, and dosages at markers using 
#' an error-prone aware hidden Markov model. 
#' 
#' @examples 
#' \dontrun{
#' out_fn <- mcptagg(mcptag = mcptag,
#'                   fq_list = fq_list,
#'                   out_dir = "",
#'                   n_threads = 10, 
#'                   n_parallel = 5, 
#'                   vcf = TRUE, 
#'                   bam_list = NULL)
#' }
#' 　
#' @importFrom parallel mcmapply
#'
#' @export
#'
mcptagg <- function(mcptag, 
                    fq_list, 
                    out_dir = "",
                    n_threads = 1,
                    n_parallel = 1,
                    vcf = FALSE, 
                    bam_list = NULL){
    if(!inherits(mcptag, "MCPtag")){
        stop("object should be a MCPtag class object.")
    }
    if(length(n_parallel) == 1){
        n_parallel <- c(n_parallel, n_parallel)
    }
    dir.create(out_dir, showWarnings = FALSE)
    aln_dir <- paste(out_dir, "aln", sep = "/")
    dir.create(aln_dir, showWarnings = FALSE)
    if(is.null(bam_list)){
        bam_list <- mcmapply(seq_len(nrow(fq_list)), mc.cores = n_parallel[1],
                             FUN = function(i){
                                 return(.alignToGenome(mcptag$index_fn,
                                                       fq_list[i, ],
                                                       n_threads,
                                                       aln_dir))
                             })
        bam_list <- cbind(bam_list, fq_list[, ncol(fq_list)])
    }
    
    count_matrix <- NULL
    for(i in seq_len(nrow(bam_list))){
        count_matrix <- cbind(count_matrix,
                              .countReads(mcptag, bam_fn = bam_list[i, 1], 
                                          rnaseq = FALSE))
    }
    
    colnames(count_matrix) <- bam_list[, 2]
    
    out_fn <- .create.gds(mcptag, count_matrix, out_dir, vcf)
    return(out_fn)
}

#' @importFrom Rsubread align
.alignToGenome <- function(index_fn, fq_fn, n_threads, aln_dir){
    if(length(fq_fn) == 2){
        bam_fn <- paste0(aln_dir, "/", fq_fn[2], ".bam")
        aln <- align(index_fn, fq_fn[1], type = "dna",
                     output_file = bam_fn,
                     nthreads = n_threads, maxMismatches = 0, unique = TRUE,
                     indels = 0)
        
    } else {
        bam_fn <- paste0(aln_dir, "/", fq_fn[3], ".bam")
        aln <- align(index_fn, fq_fn[1], fq_fn[2], type = "dna",
                     output_file = bam_fn,
                     nthreads = n_threads, maxMismatches = 0, unique = TRUE,
                     indels = 0)
    }
    return(bam_fn)
}

#' @importFrom GenomicAlignments readGAlignments cigar
#' @importFrom GenomeInfoDb seqlevels
#' @importFrom GenomicRanges grglist findOverlaps
#' @importFrom S4Vectors subjectHits
.countReads <- function(mcptag, bam_fn, rnaseq){
    ga <- readGAlignments(file = bam_fn)
    if(rnaseq){
        incomple <- grepl("S|I|D|H|P|X", cigar(ga))
        ga <- ga[!incomple]
        ga <- grglist(ga, order.as.in.query=TRUE)
        ga <- unlist(ga)
        
    } else {
        incomple <- grepl("I|D|H|P|X|N", cigar(ga))
        ga <- ga[!incomple]
    }
    
    ref_count <- table(factor(subjectHits(findOverlaps(ga, mcptag$ref)),
                              seq_along(mcptag$ref)))
    alt_count <- table(factor(subjectHits(findOverlaps(ga, mcptag$alt)),
                              seq_along(mcptag$alt)))
    count <- c(ref_count, alt_count)
    return(count)
}


#'
#' @importFrom SNPRelate snpgdsCreateGeno
#' @importFrom SeqArray seqSNP2GDS seqGDS2VCF
#' @importFrom BiocGenerics start
.create.gds <- function(mcptag, count_matrix, out_dir, vcf){
    tmp_out <- tempfile(tmpdir = tempdir(), fileext = ".snp")
    on.exit({unlink(tmp_out)})
    genmat <- .make.geno(count_matrix)
    data <- .make.ADdata(count_matrix)
    n_mar <- length(mcptag$ref)
    
    snpgdsCreateGeno(tmp_out,
                     genmat,
                     colnames(count_matrix),
                     seq_len(n_mar),
                     seq_len(n_mar),
                     sub("ref_", "", as.character(seqnames(mcptag$ref))),
                     start(mcptag$ref),
                     paste(mcptag$ref$allele, mcptag$alt$allele, sep = "/"),
                     FALSE,
                     "",
                     "",
                     list(alt.pos = start(mcptag$alt)))
    
    out_fn <- seqSNP2GDS(tmp_out, paste0(out_dir, "/genotype.gds"),
                         major.ref = FALSE, verbose = TRUE)
    .addAD(data, out_fn)
    
    if(vcf){
        out_fn <- c(out_fn,
                    seqGDS2VCF(out_fn, paste0(out_dir, "/genotype.vcf"), verbose = FALSE,
                               use_Rsamtools = TRUE))
    }
    return(out_fn)
}

.make.geno <- function(count_matrix){
    n_row <- nrow(count_matrix)/2
    n_index <- seq_len(n_row)
    genmat <- matrix(3, n_row, ncol(count_matrix))
    genmat[count_matrix[n_index, ] == 0 & count_matrix[-n_index, ] > 0] <- 0
    genmat[count_matrix[n_index, ] > 0 & count_matrix[-n_index, ] > 0] <- 1
    genmat[count_matrix[n_index, ] > 0 & count_matrix[-n_index, ] == 0] <- 2
    return(t(genmat))
}

.make.ADdata <- function(count_matrix){
    n_row <- nrow(count_matrix)/2
    n_index <- seq_len(n_row)
    data <- matrix(0, ncol(count_matrix), n_row * 2)
    data[, c(T, F)] <- t(count_matrix[n_index, ])
    data[, c(F, T)] <- t(count_matrix[-n_index, ])
    return(data)
}

#' @importFrom methods new
#' @importFrom gdsfmt index.gdsn openfn.gds put.attr.gdsn addfolder.gdsn add.gdsn closefn.gds
.addAD <- function(data, out_fn){
    gds <- openfn.gds(out_fn, FALSE)
    
    addfolder.gdsn(index.gdsn(gds, "annotation/format"), "AD")
    add.gdsn(index.gdsn(gds, "annotation/format/AD"),
             "data", data, storage = "vl_int", valdim = dim(data),
             compress = "LZMA_RA")
    add.gdsn(index.gdsn(gds, "annotation/format/AD"),
             "@data", rep(2, ncol(data)/2), storage = "int32",
             compress = "LZMA_RA", visible = FALSE)
    put.attr.gdsn(index.gdsn(gds, "annotation/format/AD"),
                  "Number", "R")
    put.attr.gdsn(index.gdsn(gds, "annotation/format/AD"),
                  "Type", "Integer")
    put.attr.gdsn(index.gdsn(gds, "annotation/format/AD"),
                  "Description",
                  "Allelic depths for the reference and alternate alleles in the order listed")
    closefn.gds(gds)
}
